<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Court Allocator by Performance Clustering</title>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<style>
body { font-family: system-ui, sans-serif; background:#f8f9fb; padding:2rem; text-align:center; }
textarea { width:95%; height:240px; font-family:monospace; font-size:1rem; border-radius:8px; border:1px solid #ccc; padding:0.5rem; }
input { width:60px; font-size:1rem; margin-left:0.5rem; }
button { background:#007aff; color:white; border:none; padding:0.7rem 1.3rem; border-radius:10px; cursor:pointer; margin-top:1rem; font-size:1rem; }
button:hover { background:#005bb5; }
#output { margin-top:1.5rem; background:white; border-radius:8px; border:1px solid #ddd; padding:1rem; text-align:left; white-space:pre-wrap; }
</style>
</head>
<body>
<h2>üè∏ Court Allocator (Score Clustering)</h2>
<p>Paste players (<b>First Last Score</b>)</p>
<textarea id="inputArea" placeholder="Alice Brown 98
David Lee 91
Maria Chen 90
John Smith 85
..."></textarea>
<p>Number of courts: <input type="number" id="numCourts" value="3" min="1"></p>
<button onclick="process()">Process</button>
<pre id="output"></pre>

<script>
function process() {
  const input = document.getElementById("inputArea").value.trim();
  const numCourts = parseInt(document.getElementById("numCourts").value);
  if (!input) return alert("Paste player list first!");
  if (!numCourts || numCourts < 1) return alert("Enter valid court number.");

  const lines = input.split(/\r?\n/).filter(Boolean);
  let players = [];
  lines.forEach(line => {
    const parts = line.split(/\s+/);
    if (parts.length < 3) return;
    const score = parseFloat(parts[parts.length - 1]);
    const first = parts[0];
    const last = parts.slice(1, -1).join(" ");
    if (!isNaN(score)) players.push({ first, last, score });
  });
  if (!players.length) return alert("No valid players detected.");

  // Sort by performance score (high ‚Üí low)
  players.sort((a, b) => b.score - a.score);

  // Waiting list if overflow
  const maxAllowed = numCourts * 7;
  let waitingList = [];
  if (players.length > maxAllowed) {
    waitingList = players.slice(maxAllowed);
    players = players.slice(0, maxAllowed);
  }

  // Cluster players by score proximity
  let courts = [];
  let currentCourt = [];
  const threshold = 8; // max score difference to stay in same court

  for (let i = 0; i < players.length; i++) {
    const p = players[i];
    if (currentCourt.length === 0) {
      currentCourt.push(p);
    } else {
      const diff = Math.abs(currentCourt[currentCourt.length - 1].score - p.score);
      if ((diff <= threshold && currentCourt.length < 7) || currentCourt.length < 4) {
        currentCourt.push(p);
      } else {
        courts.push(currentCourt);
        currentCourt = [p];
      }
    }
  }
  if (currentCourt.length) courts.push(currentCourt);

  // If any court <4 ‚Üí merge with closest in avg score
  for (let i = 0; i < courts.length; i++) {
    if (courts[i].length < 4 && courts.length > 1) {
      const avg = avgScore(courts[i]);
      let best = 0, bestDiff = Infinity;
      for (let j = 0; j < courts.length; j++) {
        if (i === j) continue;
        const diff = Math.abs(avg - avgScore(courts[j]));
        if (diff < bestDiff) { bestDiff = diff; best = j; }
      }
      courts[best] = courts[best].concat(courts[i]);
      courts.splice(i, 1);
      i--;
    }
  }

  // Trim courts if more than user entered
  if (courts.length > numCourts) {
    while (courts.length > numCourts) {
      const last = courts.pop();
      let best = 0, bestDiff = Infinity;
      const avg = avgScore(last);
      for (let j = 0; j < courts.length; j++) {
        const diff = Math.abs(avg - avgScore(courts[j]));
        if (diff < bestDiff) { bestDiff = diff; best = j; }
      }
      courts[best] = courts[best].concat(last);
    }
  }

  // Round match patterns
  const matchPatterns = {
    4: [[[1,4],[2,3]],[[1,2],[3,4]],[[1,3],[2,4]]],
    5: [[[1,4],[2,3]],[[1,2],[3,5]],[[2,5],[3,4]],[[1,3],[4,5]],[[1,5],[2,4]]],
    6: [[[1,2],[3,5]],[[1,4],[3,6]],[[2,6],[4,5]],[[1,3],[2,4]],[[2,3],[5,6]],[[1,5],[4,6]]],
    7: [[[1,6],[2,7]],[[1,5],[2,6]],[[4,5],[3,7]],[[1,4],[3,5]],[[1,2],[6,7]],[[3,4],[5,7]],[[2,3],[4,6]]]
  };

  // Build output
  let out = "";
  courts.forEach((court, i) => {
    court.sort((a,b)=>b.score-a.score);
    out += `üèê Court ${i+1} (${court.length} players)\n`;
    court.forEach((p,j)=> out += `${j+1}. ${p.first} ${p.last} ‚Äî ${p.score}\n`);
    out += "\n";
    const pattern = matchPatterns[court.length];
    if (pattern) {
      pattern.forEach((round,rIdx)=>{
        const tA = round[0].map(n=>court[n-1]?.first||`P${n}`).join(" & ");
        const tB = round[1].map(n=>court[n-1]?.first||`P${n}`).join(" & ");
        out += `Round ${rIdx+1}: (${tA}) vs (${tB})\n`;
      });
    } else out += "No match pattern for this court size.\n";
    out += "\n";
  });

  if (waitingList.length) {
    out += `‚è≥ Waiting List (${waitingList.length} players)\n`;
    waitingList.forEach(p=> out += `${p.first} ${p.last} ‚Äî ${p.score}\n`);
  }

  document.getElementById("output").textContent = out.trim();

  // Export to Excel
  const rows = [];
  courts.forEach((court, i) => {
    rows.push({ Court:`Court ${i+1}`, PlayerCount:court.length });
    court.forEach(p => rows.push({ First:p.first, Last:p.last, Score:p.score }));
    rows.push({});
  });
  if (waitingList.length) {
    rows.push({ Court:"Waiting List" });
    waitingList.forEach(p => rows.push({ First:p.first, Last:p.last, Score:p.score }));
  }
  const sheet = XLSX.utils.json_to_sheet(rows);
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, sheet, "Courts");
  XLSX.writeFile(wb, "court_allocation.xlsx");
}

function avgScore(court){ return court.reduce((s,p)=>s+p.score,0)/court.length; }
</script>
</body>
</html>
