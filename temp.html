<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Court Allocator with Waiting List</title>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<style>
body { font-family: system-ui, sans-serif; background:#f5f7fa; padding:2rem; text-align:center; }
textarea { width:95%; height:240px; font-family:monospace; font-size:1rem; border-radius:8px; border:1px solid #ccc; padding:0.5rem; }
input { width:70px; font-size:1rem; margin-left:0.5rem; }
button { background:#007aff; color:white; border:none; padding:0.7rem 1.3rem; border-radius:10px; cursor:pointer; margin-top:1rem; font-size:1rem; }
button:hover { background:#005bb5; }
#output { margin-top:1.5rem; background:white; border-radius:8px; border:1px solid #ddd; padding:1rem; text-align:left; white-space:pre-wrap; max-height:70vh; overflow:auto; font-family:monospace; }
</style>
</head>
<body>
<h2>üè∏ Court Allocator with Waiting List (4‚Äì7 Players per Court)</h2>
<p>Paste players (<b>First Last Score</b>)</p>
<textarea id="inputArea" placeholder="Alice Brown 98
David Lee 91
Maria Chen 90
John Smith 85
..."></textarea>
<p>Number of courts: <input type="number" id="numCourts" value="3" min="1"></p>
<button onclick="process()">Process</button>
<pre id="output"></pre>

<script>
function process() {
  const input = document.getElementById("inputArea").value.trim();
  const numCourts = parseInt(document.getElementById("numCourts").value);
  const outputEl = document.getElementById("output");
  outputEl.textContent = "";

  if (!input) return alert("Paste your player list first!");
  if (!numCourts || numCourts < 1) return alert("Enter a valid number of courts.");

  // Parse player list
  const lines = input.split(/\r?\n/).filter(Boolean);
  let players = [];
  lines.forEach(line => {
    const parts = line.split(/\s+/);
    if (parts.length < 3) return;
    const score = parseFloat(parts[parts.length - 1]);
    const first = parts[0];
    const last = parts.slice(1, -1).join(" ");
    if (!isNaN(score)) players.push({ first, last, score });
  });

  if (!players.length) return alert("No valid players detected!");

  // Step 1: compute capacity
  const capacity = numCourts * 7;

  // Step 2: move players beyond capacity to waiting list (unsorted)
  let waitingList = [];
  if (players.length > capacity) {
    waitingList = players.slice(capacity);
    players = players.slice(0, capacity);
  }

  // Step 3: sort remaining players (eligible) by score
  players.sort((a,b)=>b.score - a.score);

  // Step 4: divide sorted players into courts (each 4‚Äì7)
  const total = players.length;
  let courts = [];
  let base = Math.floor(total / numCourts);
  let remainder = total % numCourts;
  if (base < 4) base = 4;

  let start = 0;
  for (let i = 0; i < numCourts; i++) {
    let size = base + (remainder > 0 ? 1 : 0);
    remainder--;
    let group = players.slice(start, start + size);
    if (group.length > 0) courts.push(group);
    start += size;
  }

  // Merge if last court < 4 players
  if (courts.length > 1 && courts[courts.length - 1].length < 4) {
    const last = courts.pop();
    courts[courts.length - 1].push(...last);
  }

  // Step 5: define match patterns
  const matchPatterns = {
    4: [[[1,4],[2,3]],[[1,2],[3,4]],[[1,3],[2,4]]],
    5: [[[1,4],[2,3]],[[1,2],[3,5]],[[2,5],[3,4]],[[1,3],[4,5]],[[1,5],[2,4]]],
    6: [[[1,2],[3,5]],[[1,4],[3,6]],[[2,6],[4,5]],[[1,3],[2,4]],[[2,3],[5,6]],[[1,5],[4,6]]],
    7: [[[1,6],[2,7]],[[1,5],[2,6]],[[4,5],[3,7]],[[1,4],[3,5]],[[1,2],[6,7]],[[3,4],[5,7]],[[2,3],[4,6]]]
  };

  // Step 6: build output
  let out = "";
  courts.forEach((court, i) => {
    court.sort((a,b)=>b.score-a.score);
    out += `üèê Court ${i+1} (${court.length} players)\n`;
    court.forEach((p,j)=> out += `${j+1}. ${p.first} ${p.last} ‚Äî ${p.score}\n`);
    out += "\n";

    const pattern = matchPatterns[court.length];
    if (pattern) {
      pattern.forEach((round,rIdx)=>{
        const teamA = round[0].map(n=>court[n-1]?.first||`P${n}`).join(" & ");
        const teamB = round[1].map(n=>court[n-1]?.first||`P${n}`).join(" & ");
        out += `Round ${rIdx+1}: (${teamA}) vs (${teamB})\n`;
        out += "Score: ____________\n\n";
      });
    } else {
      out += "No match pattern for this court size.\n";
    }
    out += "\n";
  });

  if (waitingList.length) {
    out += `‚è≥ Waiting List (${waitingList.length} players)\n`;
    waitingList.forEach(p=> out += `${p.first} ${p.last} ‚Äî ${p.score}\n`);
  }

  outputEl.textContent = out.trim();

  // Step 7: Excel export
  const rows = [];
  courts.forEach((court, i) => {
    rows.push({ Court:`Court ${i+1}`, PlayerCount:court.length });
    court.forEach(p => rows.push({ First:p.first, Last:p.last, Score:p.score }));
    rows.push({});
    const pattern = matchPatterns[court.length];
    if (pattern) {
      pattern.forEach((round,rIdx)=>{
        const teamA = round[0].map(n=>court[n-1]?.first||`P${n}`).join(" & ");
        const teamB = round[1].map(n=>court[n-1]?.first||`P${n}`).join(" & ");
        rows.push({ Round:`Round ${rIdx+1}`, Match:`(${teamA}) vs (${teamB})`, Score:"" });
      });
    }
    rows.push({});
  });
  if (waitingList.length) {
    rows.push({ Court:"Waiting List" });
    waitingList.forEach(p => rows.push({ First:p.first, Last:p.last, Score:p.score }));
  }

  const sheet = XLSX.utils.json_to_sheet(rows);
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, sheet, "Courts");
  XLSX.writeFile(wb, "court_allocation.xlsx");
}
</script>
</body>
</html>
